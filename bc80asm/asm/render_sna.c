#include <stdio.h>
#include <string.h>

#include "asm/render.h"
#include "asm/snafmt.h"
#include "bits/buffer.h"

const uint8_t zx_udg_data[] = {
  0x00, 0x3c, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x00, 0x00, 0x7c, 0x42, 0x7c, 0x42, 0x42, 0x7c, 0x00,
  0x00, 0x3c, 0x42, 0x40, 0x40, 0x42, 0x3c, 0x00, 0x00, 0x78, 0x44, 0x42, 0x42, 0x44, 0x78, 0x00,
  0x00, 0x7e, 0x40, 0x7c, 0x40, 0x40, 0x7e, 0x00, 0x00, 0x7e, 0x40, 0x7c, 0x40, 0x40, 0x40, 0x00,
  0x00, 0x3c, 0x42, 0x40, 0x4e, 0x42, 0x3c, 0x00, 0x00, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x42, 0x00,
  0x00, 0x3e, 0x08, 0x08, 0x08, 0x08, 0x3e, 0x00, 0x00, 0x02, 0x02, 0x02, 0x42, 0x42, 0x3c, 0x00,
  0x00, 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7e, 0x00,
  0x00, 0x42, 0x66, 0x5a, 0x42, 0x42, 0x42, 0x00, 0x00, 0x42, 0x62, 0x52, 0x4a, 0x46, 0x42, 0x00,
  0x00, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x7c, 0x42, 0x42, 0x7c, 0x40, 0x40, 0x00,
  0x00, 0x3c, 0x42, 0x42, 0x52, 0x4a, 0x3c, 0x00, 0x00, 0x7c, 0x42, 0x42, 0x7c, 0x44, 0x42, 0x00,
  0x00, 0x3c, 0x40, 0x3c, 0x02, 0x42, 0x3c, 0x00, 0x00, 0xfe, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00,
  0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00
};

const uint8_t zx_sysvars_data[] = {
  0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x14, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x06, 0x00, 0x0b, 0x00, 0x01, 0x00, 0x01, 0x00, 0x06, 0x00, 0x10, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x40, 0x00, 0xff, 0xcc, 0x01, 0x54, 0xff, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0xcb, 0x5c, 0x00, 0x00, 0xb6,
  0x5c, 0xb6, 0x5c, 0xcb, 0x5c, 0x00, 0x00, 0xca, 0x5c, 0xcc, 0x5c, 0xcc, 0x5c, 0xcc, 0x5c, 0x00,
  0x00, 0xce, 0x5c, 0xce, 0x5c, 0xce, 0x5c, 0x00, 0x92, 0x5c, 0x10, 0x02, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0xff, 0x00, 0x00, 0x21,
  0x5b, 0x00, 0x21, 0x17, 0x00, 0x40, 0xe0, 0x50, 0x21, 0x18, 0x21, 0x17, 0x01, 0x38, 0x00, 0x38,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x57, 0xff, 0xff, 0xff, 0xf4, 0x09, 0xa8, 0x10, 0x4b, 0xf4, 0x09, 0xc4, 0x15, 0x53,
  0x81, 0x0f, 0xc4, 0x15, 0x52, 0xf4, 0x09, 0xc4, 0x15, 0x50, 0x80, 0x80, 0x0d, 0x80, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const uint8_t zx_stack_data[] = {
  0x03, 0x13, 0x00, 0x3e
};

#define ZX_ATTRIBUTE(ink, paper, bright, flash) \
  ((ink & 0x7) | ((paper & 0x7) << 3) | ((bright & 0x1) << 6) | ((flash & 0x1) << 7))
#define ZX_COLOR_WHITE 7

#define ZX_VIDEOATTR_START 0x5800
#define ZX_VIDEOATTR_END 0x5B00
#define ZX_SYSVARS_START 0x5C00
#define ZX_UDG_START 0xFF58

uint32_t render_sna(compile_ctx_t *ctx, char **dest_buf)
{
  buffer *snafmt = buffer_init();
  struct snafmt_header *header;
  uint32_t snafmt_size = 0;
  char *ram_snapshot_start;
  uint16_t pc_value;
  dynarray_cell *dc;

  buffer_reserve(snafmt, sizeof(struct snafmt_header) + SNA_SNAPSHOT_RAM_SIZE);

  memset(snafmt->data, 0, snafmt->len);

  header = (struct snafmt_header *) snafmt->data;

  ram_snapshot_start = snafmt->data + sizeof(struct snafmt_header);

  int sna_pc_addr = ctx->opts.sna_pc_addr;
  int sna_ramtop = ctx->opts.sna_ramtop;

  // decide which value assign for snapshot's PC
  if (sna_pc_addr != -1) {
    if (sna_pc_addr < SNA_SNAPSHOT_ROM_SIZE) {
      report_warning_noloc("snapshot PC value refers to ROM area");
    }

    pc_value = sna_pc_addr;
  } else {
    uint32_t lowest_start = 0xffff;

    // get lowest section start address
    foreach (dc, ctx->sections) {
      section_ctx_t *section = (section_ctx_t *)dfirst(dc);

      // don't take into account empty sections
      if (section->content->len > 0 && section->start < lowest_start)
        lowest_start = section->start;
    }

    pc_value = lowest_start;
  }

  // copy sections content into RAM snapshot
  foreach (dc, ctx->sections) {
    section_ctx_t *section = (section_ctx_t *)dfirst(dc);

    // skip empty sections
    if (section->content->len == 0)
      continue;

    if (section->start < SNA_SNAPSHOT_ROM_SIZE) {
      report_error_noloc("can't place section '%s' with start address 0x%x into RAM snapshot",
        section->name, section->start);
    }

    if (section->start - SNA_SNAPSHOT_ROM_SIZE + section->content->len > SNA_SNAPSHOT_RAM_SIZE) {
      report_error_noloc("can't place section '%s' with size %d into RAM snapshot due RAM size overflow",
        section->name, section->content->len);
    }

    memcpy(ram_snapshot_start + (section->start - SNA_SNAPSHOT_ROM_SIZE),
      section->content->data, section->content->len);
  }

  // initialize spectrum48 RAM system area (attributes, UDG, SYSVARS etc) if requested
  if (!ctx->opts.sna_generic) {
    uint32_t addr;

    header->border = ZX_COLOR_WHITE;

    // spectrum ROM routines requires value 0x5c3a (offset to system variable ERR-NR)
    // loaded into IY (in real world it initilizes at NEW and keeps during system operates)
    header->iy = 0x5c3a;

    for (addr = ZX_VIDEOATTR_START; addr < ZX_VIDEOATTR_END; addr++)
      ram_snapshot_start[addr - SNA_SNAPSHOT_ROM_SIZE] = ZX_ATTRIBUTE(1, ZX_COLOR_WHITE, 1, 0);

    for (addr = ZX_UDG_START; addr < ZX_UDG_START + sizeof(zx_udg_data); addr++)
      ram_snapshot_start[addr - SNA_SNAPSHOT_ROM_SIZE] = zx_udg_data[addr - ZX_UDG_START];

    for (addr = ZX_SYSVARS_START; addr < ZX_SYSVARS_START + sizeof(zx_sysvars_data); addr++)
      ram_snapshot_start[addr - SNA_SNAPSHOT_ROM_SIZE] = zx_sysvars_data[addr - ZX_SYSVARS_START];

    // RAMTOP system variable
    ram_snapshot_start[ZX_SYSVARS_START + 0xb2 - SNA_SNAPSHOT_ROM_SIZE] =
      sna_ramtop & 0xff;
    ram_snapshot_start[ZX_SYSVARS_START + 0xb3 - SNA_SNAPSHOT_ROM_SIZE] =
      (sna_ramtop >> 8) & 0xff;

    addr = sna_ramtop + 1 - sizeof(zx_stack_data);

    // ERRSP system variable
    ram_snapshot_start[ZX_SYSVARS_START + 0x3d - SNA_SNAPSHOT_ROM_SIZE] =
      addr & 0xff;
    ram_snapshot_start[ZX_SYSVARS_START + 0x3e - SNA_SNAPSHOT_ROM_SIZE] =
      (addr >> 8) & 0xff;

    // add default ZX stack
    for (int i = 0; i < sizeof(zx_stack_data); i++, addr++)
      ram_snapshot_start[addr - SNA_SNAPSHOT_ROM_SIZE] = zx_stack_data[i];

    // adjust stack pointer
    sna_ramtop = sna_ramtop + 1 - sizeof(zx_stack_data) - sizeof(uint16_t);
  }

  header->sp = sna_ramtop;

  // inject PC into top of stack
  ram_snapshot_start[sna_ramtop + 1 - SNA_SNAPSHOT_ROM_SIZE] = (pc_value >> 8) & 0xff;
  ram_snapshot_start[sna_ramtop - SNA_SNAPSHOT_ROM_SIZE] = pc_value & 0xff;

  *dest_buf = buffer_dup(snafmt);
  snafmt_size = snafmt->len;
  buffer_free(snafmt);

  return snafmt_size;
}
